---
title: "도커 소개"
excerpt: "와! 컨테이너!"

categories:
    - Tech
tags:
    - Docker
last_modified_at: 2020-01-03T14:55:00
---

Docker란?
=========

Docker(이하 도커)는 이미지 기반의 가상화 서비스 엔진 입니다.
github와 유사한 느낌의 Docker hub가 운영되고 있으며, 여기에서 여러 개발자들이 생성한 이미지를 내려받아 도커로 실행해볼 수 있습니다.

git처럼 이미지 내에서 변경된 사항 또한 알 수 있으며, 이미지로 버전관리를 할 수 있습니다. 각각의 이미지는 실행시 컨테이너로 격리됩니다.

도커는 이 이미지로 컨테이너를 만들고, 여러개의 컨테이너를 쌓아 프로세스를 실행합니다. 이때 쌓아올린 컨테이너를 레이어라고 합니다.

예를 들어, ubuntu 이미지를 받고 이를 기반으로 생성한 python 이미지가 있다고 가정하면, python 이미지를 받을때 ubuntu 이미지에 포함된 컨테이너를 함께 받게 됩니다.

실제로 컨테이너를 실행중일때도, 변경사항이 생긴 컨테이너에서 실제로 변경된 부분만 기록하므로 이미지의 크기도 크게 바뀌지 않습니다.

-----

이미지?
-------

이미지는 프로세스를 실행하기 위해 필요한 리눅스 베이스 파일이 담긴것과 이 베이스 파일에 필요한 라이브러리가 설치된 것이 있습니다.
보통 베이스 이미지를 받아서 직접 라이브러리를 설치하거나, 필요한 라이브러리가 이미 설치된 이미지를 받아서 실행합니다.

-----

컨테이너?
---------

컨테이너란 이미지에서 생성된 가상공간으로 볼 수 있습니다.
실행 옵션에 따라 생성된 컨테이너는 시작할 수도 있고, 중단할 수도 있고, 삭제할 수도 있습니다. 이미지에서 실행되는 프로세스를 컨테이너라는 이름으로 관리한다고 생각하면 편할 것 같습니다.

-----

##  그럼 어떻게 써요?

기본적인 사용법은 다음과 같습니다.

- 이미지 검색
    > docker search imagename:tag
- 이미지 받기
    > docker pull imagename:tag
- 이미지 실행하기(pull이 포함)
    > docker run (옵션) imagename:tag
- 이미지 삭제하기
    > docker rmi imagename:tag
- 이미지 목록 출력하기
    > docker images
- 컨테이너 만들기
    > docker creat (옵션) imagename:tag
- 컨테이너 실행하기
    > docker start (옵션) contname
- 컨테이너 재실행하기
    > docker restart contname
- 컨테이너 실행중지 하기
    > docker stop contname
- 컨테이너 삭제하기
    > docker rm (옵션) contname
- 컨테이너 목록 보기
    > docker ps (옵션)
- 컨테이너 접속하기
    > docker attach (옵션) contname
- 호스트에서 컨테이너 속에 명령 내리기
    > docker exec (옵션) contname

-----

## 그래서 이걸 왜 써요?

도커를 쓰는 이유는 프로세스의 격리(가상화)도 있지만, 가장 중요한건 Dockerfile과 Docker-compose로 이루는 환경구성 및 실행의 자동화가 가장 큰 장점이라고 생각합니다.

서비스가 복잡 해질수록 이 도커파일과 컴포즈 파일을 작성하는게 함께 복잡해지겠지만, 한번 구성된 설정파일만 있으면 어느 서버에서든지 동일한 환경의 서비스를 안전하게 갖출 수 있다는 큰 매력이 있으니까요.

학부생 레벨에서는 개인 컴퓨터에서만 개발하고, 배포를 하지않거나 과제로 제출 정도만 해보기때문에 필요성을 잘 못느끼지만, 실제 서비스시 서버만 해도 수백개가 넘어가는 상황에서는 절실한 기능인 것 같습니다.

-----

## Dockerfile은 또 뭐에요? compose는요?

위의 명령어 예시중 run을 한번 보겠습니다.

> docker run imagename:tag

간단하죠? 하지만 이대로 실행하면 바로 종료되어 버리는 프로세스들도 있습니다.
또 호스트에 있는 설정파일이나 소스파일을 컨테이너 내부에 넣어서 실행 해야하는 경우도 분명 있습니다.
나중에 관리하기 쉽게 이름을 붙여줄 수도 있죠.

이럴때 우리는 run에 옵션을 붙여서 사용합니다. -i -t -d --rm --name -v 등등...
하지만 매번 실행할때마다 이런 옵션을 일일이 다 기록해놨다가 붙여넣는다거나, 이미지마다 보관해두는것도 굉장히 피곤한 일입니다.

따라서, 이런 실행옵션과 사전에 준비할 내용을 정리해 파일로 만든것이 바로 dockerfile입니다.

최상단에는 반드시 사용할 이미지를 명시해야 하고, 해당 이미지를 받은뒤 컨테이너를 어떻게 실행할지, 호스트에서 어떤 파일을 복사해넣을지 등등을 설정해두고 나중에 사용할때는 build 명령 하나만 쓰면 됩니다.


다 좋습니다! 이제 도커를 이용해 가상화도 할수있고, 도커파일을 이용해 귀찮은 실행 명령어를 일일이 터미널에 타이핑할 필요도 없습니다. 하지만, 여기서 가상화 덕분에 생기는 문제가 하나 있습니다.

바로 컨테이너 내부에서 실행되는 프로세스는 외부(호스트)의 환경을 전혀 알수없고, 호스트 또한 exec명령어 등이 아니면 컨테이너 내부에 접근할 수가 없는 문제인데요, 그럼 웹서버 컨테이너가 있고 데이터베이스 컨테이너가 있을땐 어떻게 할까요?

간단한 방법은 웹서버를 run할때, 옵션으로 --links (컨테이너명)을 명시해주면 해당 컨테이너와 통신을 할 수 있게 됩니다.

하지만 동시에 실행해야할 컨테이너가 여러개라면? 세개, 네개, 수십개가 된다면 이것도 일일이 옵션을 명시하거나 각각의 도커파일에 전부 써줄 수도 없는 노릇이죠.

그래서 이를 더 편하게 구성하기 위해 docker-compose가 나왔습니다.

docker-compose라는 이름의 yml파일을 작성해두면, 해당 파일에 작성된 컨테이너들은 서로 하나의 가상 네트워크 안에서 통신을 할수있게 됩니다. 물론 호스트에서 접속하기 위한 포트 설정도 할 수 있고, 이미지 하나하나 build를 해줘야했던 전과 다르게 이제는 

> docker-compose up

명령어 하나로 전부 실행하고, down을 쓰면 모두 종료할 수 있게 되었습니다.
또, down 명령어는 단순히 종료할 뿐만 아니라 stop과 rm이 같이 일어나기 때문에 docker ps를 입력하고, 이름을 확인하고, 하나하나 일일이 rm으로 지워줄 필요가 전혀 없습니다.

이제 우리는 docker-compose까지 이용해서 편리한 환경 구축과 서비스 실행을 할 수 있게 되었습니다.